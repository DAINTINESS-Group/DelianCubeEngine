package mainengine;


import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import org.apache.commons.lang3.StringUtils;
import cubemanager.CubeManager;
import cubemanager.cubebase.CubeQuery;
import result.Result;


/**
 * 
 * A class for the intentional operator Analyze
 * Implemented so far: intentional query syntax validation, intentional query translation to
 * base cube query (straightforward translation), cube query drill downs (one level below for each gamma
 * expression) and cube query siblings (for each sigma expression, get his parent hierarchy and value)
 */

public class AnalyzeOperator {
	// the intentional query given by SQP class
	private String incomingExpression;
	
	// CubeManager object to manage the cube
	private CubeManager cubeManager;
	
	// A Set of keywords in order to use the contains method to check if certain characters exists in the incoming expression
	private HashSet<String> keyWords;
	
	// An ArrayList of CubeQuery objects that stores the translated cube queries
	private ArrayList<CubeQuery> analyzeCubeQueries = new ArrayList<CubeQuery>();
	
	/**
	 * Initialize AnalyzeOperator object
	 * @param incomingExpression An intentional query to be executed that follow the Analyze Operator syntax
	 * @param cubeManager A cube manager to manage the cube
	 */
	public AnalyzeOperator(String incomingExpression, CubeManager cubeManager) {
		this.incomingExpression = incomingExpression;
		this.cubeManager = cubeManager;
		this.keyWords = new HashSet<>(Arrays.asList("AND"," "));
	}
	
	/** Auxiliary method that returns the cube queries which were generated by the analyze input expression, using the CubeQueries.toString() method
	 * 
	 * @return A string with the cube queries seperated by newline character(\n)
	 */
	public String getAnalyzeCubeQueriesString() {
		String retString = "";
		for(CubeQuery cq: analyzeCubeQueries) {
			retString += cq.toString() + "\n";
		}
		return retString;
	}
	
	/**
	 * Auxiliary method that checks if the syntax of the intentional query given is correct
	 * The syntax that is considered correct is: <p>
	 * AnalyzeOperator: ANALYZE aggregateFunction measure FROM cubeName FOR sigmaExpressions BY gammaExpression <p>
	 * sigmaExpressions: hierarchy=value multipleExpressions <p>
	 * multipleExpressions: (AND hierarchy=value)*<p>
	 * gammaExpressions: hierarchy, hierarchy <p>
	 * Sigma Expressions are seperated with the word AND. Gamma Expressions are seperated with commas(,).<br>
	 * Sigma Expressions must not contain gaps. For example region=Prague is acceptable but region = Prague is not. Also, if the value of a
	 * sigma expression contains gaps replace them with underscores(_) and the translateInputAnalyzeExpressionToCubeQueries method will replace them back to gaps.
	 * No '' are needed to surround the values of a sigma expression, they are added too.<p>  
	 * @param incomingExpression An intentional query to be checked if it follows the Analyze Operator syntax
	 * @return A boolean value that responds to the question "Is the incoming expressions valid?"
	 */
	public boolean validateIncomingExpression(String incomingExpression) {
		int sigmaExpressionsCounter = 0;
		boolean foundDimension = false;
		HashSet<String> aggregateFunctions = new HashSet<>(Arrays.asList("min","max","avg","sum"));
		
		// split incoming expression by gap characters
		String[] tokens = incomingExpression.split(" ");
		
		// check if there are gaps in sigma expressions
		for(String str:tokens) {
			if(str.equals("=")) {
				System.out.println("Analyze Operator Syntax Error: No gaps allowed between values and '=' char in FOR clause.");
				return false;
			}
		}
		
		// check if keyword are in the correct position and written an they should
		if(!tokens[0].equals("ANALYZE")) {
			System.out.println("Analyze Operator Syntax Error: ANALYZE keyword is either missing or mispelled.");
			return false;
		}else if(!aggregateFunctions.contains(tokens[1])) {
			System.out.println("Analyze Operator Syntax Error: Aggregate Function is either missing or mispelled or written in capitalized letters.");
			return false;
		}else if(!tokens[3].equals("FROM")) {
			System.out.println("Analyze Operator Syntax Error: FROM keyword is either missing or mispelled or there are more than one aggregate function or measure.");
			return false;
		}else if(!tokens[5].equals("FOR")) {
			System.out.println("Analyze Operator Syntax Error: FOR keyword is either missing or mispelled or there are more than one cube names.");
			return false;
		}else if(tokens[tokens.length-1].contains(",")) {
			System.out.println("Analyze Operator Syntax Error: Add gap between comma character and the next value in BY clause.");
			return false;
		}
		
		// find the number of sigma expressions 
		for(int i = 5;i < tokens.length;i++) {
			if(tokens[i].contains("=")) {
				sigmaExpressionsCounter++;
			}
		}
		
		// check if BY keyword is where it should
		if(!tokens[5+2*sigmaExpressionsCounter].equals("BY")) {
			System.out.println("Analyze Operator Syntax Error: BY/AND keyword is missing or mispelled or there are gaps in values of FOR clause.");
			return false;
		}
		
		// check if the hierarchies given on the sigma expressions exist in the cube
		for(int i = 6;i < 6+2*sigmaExpressionsCounter;i = i+2) {
			String dimension = tokens[i].split("=")[0];
			for(int j = 0;j < cubeManager.getDimensions().size();j++) {
				for(int k = 0;k < cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().size();k++){
					if(cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k).getName().equals(dimension)) {
						foundDimension = true;
					}
				}
			}
			if(!foundDimension) {
				System.out.println("Analyze Operator Syntax Error: Dimension '" + dimension + "' doesn't exist.");
				return false;
			}
			foundDimension = false;
		}
		
		// check if the hierarchies given on the gamma expressions exist in the cube
		for(int i = 6+2*sigmaExpressionsCounter;i < tokens.length;i++) {
			String dimension = tokens[i].split(",")[0];
			for(int j = 0;j < cubeManager.getDimensions().size();j++) {
				for(int k = 0;k < cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().size();k++){
					if(cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k).getName().equals(dimension)) {
						foundDimension = true;
					}
				}
			}
			if(!foundDimension) {
				System.out.println("Analyze Operator Syntax Error: Dimension '" + dimension + "' doesn't exist.");
				return false;
			}
			foundDimension = false;
		}
		
		// if all checks are cleared, then the incoming expression syntax is correct
		return true;
	}

	/**
	 * Converts an analyze intentional query to the respective CubeQuery objects via simple string processing.<br>
	 * The method fills the analyzeCubeQueries ArrayList with the base cube query, its drill-downs and its siblings.
	 */
	
	private void translateInputAnalyzeExpressionToCubeQueries() {
		// CubeQuery string attributes
		String cubeName;
		String name;
		String aggregateFunction;
		String measure;
		String sigmaExpressions;
		String gammaExpressions;
		
		String tokens = "";
		String level= "";
		String sigmaExpressionSplitted;
		String sigmaExpressionValue;
		String cubeQString;
		boolean found = false;
		boolean isIncomingExpressionValid;
		String[] sigmaExpressionsArray;
		String[] gammaExpressionsArray;
		
		// HashMap that will produce the CubeQuery
		HashMap<String,String> queryParams = new HashMap<String,String>();
		CubeQuery analyzeBaseQuery = null;
		
		// check if incoming expression is valid in order to proceed translation
		isIncomingExpressionValid = validateIncomingExpression(incomingExpression);
		if(!isIncomingExpressionValid) {
			return;
		}
		
		// find the tokens of the incoming expression
		String[] splittedExpression = this.incomingExpression.split(" ");
		for(int i = 0;i<splittedExpression.length;i++) {
			if(!this.keyWords.contains(splittedExpression[i])) {
				if(splittedExpression[i].charAt(splittedExpression[i].length() - 1) == ',') {
					splittedExpression[i] = splittedExpression[i].substring(0, splittedExpression[i].length() - 1);
				}
				tokens += splittedExpression[i] + " ";
			}
		}
		// extract CubeQuery attributes from token list
		aggregateFunction = tokens.split("FROM")[0].split(" ")[1];
		measure = tokens.split("FROM")[0].split(" ")[2];
		cubeName = tokens.split("FOR")[0].split(" ")[4];
		sigmaExpressionsArray = tokens.split("FOR")[1].split("BY")[0].split(" ");
		gammaExpressionsArray = tokens.split("BY")[1].split(" ");
		
		// find the dimensions of the gamma Expressions
		for(int i = 1;i < gammaExpressionsArray.length;i++)
			for(int j = 0;j < cubeManager.getDimensions().size();j++) {
				for(int k = 0;k < cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().size();k++) {
					level = cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k).getName();
					if(level.equals(gammaExpressionsArray[i])) {
						gammaExpressionsArray[i] = cubeManager.getDimensions().get(j).getName() + "." + gammaExpressionsArray[i];
						found = true;
						break;
					}
				}
				if(found) {
					found = false;
					break;
				}
			}
		
		// find the dimensions of the sigma expressions
		for(int i = 1;i < sigmaExpressionsArray.length;i++) {
			sigmaExpressionSplitted = sigmaExpressionsArray[i].split("=")[0];
			sigmaExpressionValue =  sigmaExpressionsArray[i].split("=")[1];
			for(int j = 0;j < cubeManager.getDimensions().size();j++) {
				for(int k = 0;k < cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().size();k++) {
					level = cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k).getName();
					if(level.equals(sigmaExpressionSplitted)) {
						if(sigmaExpressionValue.contains("_")) {
							sigmaExpressionValue = sigmaExpressionValue.replace("_" , " ");
						}
						sigmaExpressionsArray[i] = cubeManager.getDimensions().get(j).getName() + "." + sigmaExpressionSplitted + "=" + "'" + sigmaExpressionValue + "'";
						found = true;
						break;
					}
				}
				if(found) {
					found = false;
					break;
				}
			}
		}
		
		// set up the string to produce the CubeQuery
		cubeName = "CubeName:" + cubeName + "\n";
		name = "Name:AnalyzeBaseQuery" + "\n";
		aggregateFunction = "AggrFunc:" + StringUtils.capitalize(aggregateFunction) + "\n";
		measure = "Measure:" + measure + "\n";
		gammaExpressions = "Gamma:";
		for(int i = 1;i < gammaExpressionsArray.length;i++) {
			if(i <  gammaExpressionsArray.length - 1) {
				gammaExpressions += gammaExpressionsArray[i] + ",";
			}else {
				gammaExpressions += gammaExpressionsArray[i];
			}
		}
		gammaExpressions += "\n";
		sigmaExpressions = "Sigma:";
		for(int i = 1;i < sigmaExpressionsArray.length;i++) {
			if(i <  sigmaExpressionsArray.length - 1) {
				sigmaExpressions += sigmaExpressionsArray[i] + ",";
			}else {
				sigmaExpressions += sigmaExpressionsArray[i];
			}
		}
		sigmaExpressions += "\n";
		cubeQString = cubeName + name + aggregateFunction + measure + gammaExpressions + sigmaExpressions;
		
		// set up the queryParams HashMap
		queryParams.put("CubeName", cubeName);
		queryParams.put("Name", "AnalyzeBaseQuery");
		queryParams.put("AggrFunc", aggregateFunction);
		queryParams.put("Measure", measure);
		queryParams.put("Gamma", gammaExpressions);
		queryParams.put("Sigma", sigmaExpressions);
		
		// create the Cube Query and store it
		try {
			analyzeBaseQuery = cubeManager.createCubeQueryFromString(cubeQString, queryParams);
			analyzeCubeQueries.add(analyzeBaseQuery);
	
		} catch (RemoteException e) {
			e.printStackTrace();
		}
		
		// calculate base query drill-downs
		generateDrillDowns(cubeName,aggregateFunction,measure,gammaExpressions,sigmaExpressions);
	
		// calculate base query siblings
		generateSiblings(cubeName,aggregateFunction,measure,gammaExpressions,sigmaExpressions);
	}
	
	/**
	 * Generates the drill-down CubeQueries of the base Analyze Cube Query.<br>
	 * After drill-down CubeQueries creation, the method adds them to the analyzeCubeQueries ArrayList.
	 * @param cubeName Name of the cube of the base cube query
	 * @param aggregateFunction The aggregate function used by base cube query
	 * @param measure: The measure used by base cube query
	 * @param gammaExpressions: The gamma expressions used by base cube query
	 * @param sigmaExpressions: The sigma expressions used by base cube query
	 */
	
	private void generateDrillDowns(String cubeName,String aggregateFunction, String measure, String gammaExpressions, String sigmaExpressions) {
		String dimension;
		String currentLevel;
		String drillDownGammaExpression;
		String drillDownCubeQString;
		int positionInHierarchy;
		int index = 0;
		int maxIndex;
		boolean firstDimensionInBottom = false;
		CubeQuery drillDownAnalyzeBaseQuery;
		ArrayList<String> drillDownExpressions = new ArrayList<String>();
		ArrayList<String> drillDownGammaExpressions = new ArrayList<String>();
		HashMap<String,String> drillDownQueryParams = new HashMap<String,String>();
		
		// Split gamma expression string to get the actual expressions and save the number of expressions
		String[] expressions = gammaExpressions.split(":")[1].split(",");
		maxIndex = expressions.length;
		
		// for each grouper dimension go one level down in the hierarchy and save the new gamma expression on an ArrayList 
		for(int i = 0;i < expressions.length;i++) {
			dimension = expressions[i].split("\\.")[0];
			currentLevel = expressions[i].split("\\.")[1].replace("\n", "");
			for(int j = 0;j < cubeManager.getDimensions().size();j++) {
				if(cubeManager.getDimensions().get(j).getName().equals(dimension)) {
					for(int k = 0;k < cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().size();k++) {
						if(cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k).getName().equals(currentLevel)) {
							positionInHierarchy = cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k).getPositionInHierarchy();
							if(positionInHierarchy != 0) {
								String drillDownExpression = dimension + "." + cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k-1).getName();
								drillDownExpressions.add(drillDownExpression);
							}else {
								if(i == 0) {
									firstDimensionInBottom = true;
								}
							}
						}
					}
				}
			}
		}
		
		// create the new string expressions for the drill-downs
		for(int i = 0;i < drillDownExpressions.size();i++) {
			if(i == index) {
				if(firstDimensionInBottom) {
					index = i;
					maxIndex -=1;
				}else {
					index++;
				}
				while(index < maxIndex) {
					if(firstDimensionInBottom) {
						drillDownGammaExpression = "Gamma:" + expressions[index] + "," + drillDownExpressions.get(i);
					}else {
						drillDownGammaExpression = "Gamma:" + drillDownExpressions.get(i) + "," + expressions[index];
					}
					drillDownGammaExpression = drillDownGammaExpression.replace("\n","");
					drillDownGammaExpression += "\n";
					drillDownGammaExpressions.add(drillDownGammaExpression);
					index++;
				}
			}else {
				while(index < i) {
					drillDownGammaExpression = "Gamma:" + expressions[index] + "," + drillDownExpressions.get(i);
					drillDownGammaExpression = drillDownGammaExpression.replace("\n","");
					drillDownGammaExpression += "\n";
					drillDownGammaExpressions.add(drillDownGammaExpression);
					index++;
				}
			}
			index = 0;
		}
		
		// set-up the necessary parameters to create the drill-down query
		for(int i = 0;i < drillDownGammaExpressions.size();i++) {
			drillDownQueryParams.clear();
			drillDownCubeQString = cubeName + "Name:AnalyzeBaseQuery-Drill Down " + (i+1) + "\n" + aggregateFunction + measure + drillDownGammaExpressions.get(i) + sigmaExpressions;
			drillDownQueryParams.put("CubeName", cubeName);
			drillDownQueryParams.put("Name", "AnalyzeBaseQuery-Drill Down " + (i+1));
			drillDownQueryParams.put("AggrFunc", aggregateFunction);
			drillDownQueryParams.put("Measure", measure);
			drillDownQueryParams.put("Gamma", drillDownGammaExpressions.get(i));
			drillDownQueryParams.put("Sigma", sigmaExpressions);
			
			// create the query and store it
			try {
				drillDownAnalyzeBaseQuery = cubeManager.createCubeQueryFromString(drillDownCubeQString, drillDownQueryParams);
				analyzeCubeQueries.add(drillDownAnalyzeBaseQuery);
			} catch (RemoteException e) {
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Produces the sibling queries of the base Analyze Cube Query.<br>
	 * After siblings CubeQueries creation, the method adds them to the analyzeCubeQueries ArrayList.
	 * @param cubeName Name of the cube of the base cube query
	 * @param aggregateFunction The aggregate function used by base cube query
	 * @param measure The measure used by base cube query
	 * @param gammaExpressions The gamma expressions used by base cube query
	 * @param sigmaExpressions The sigma expressions used by base cube query
	 */
	private void generateSiblings(String cubeName,String aggregateFunction, String measure, String gammaExpressions, String sigmaExpressions) {
		String dimension;
		String currentLevel;
		String expression;
		String parentLevel;
		String parentLevelByDescription;
		String parentValue;
		String tableName;
		String currentLevelByDescription;
		String siblingCubeQString;
		int positionInHierarchy;
		int index = 0;
		int counter = 1;
		CubeQuery siblingAnalyzeBaseQuery;
		ArrayList<String> siblingsGammaExpressionsStringForm = new ArrayList<String>();
		ArrayList<String> siblingsSigmaExpressionsStringForm = new ArrayList<String>();
		ArrayList<String> parentSigmaExpressions = new ArrayList<String>();
		HashMap<String,String> siblingQueryParams = new HashMap<String,String>();

		// get gamma and sigma expressions on arrays
		String[] gammaExpressionsArray = gammaExpressions.split(":")[1].split(",");
		String[] sigmaExpressionsArray = sigmaExpressions.split(":")[1].split(",");
		
		// for each sigma expression find its parent hierarchy and value
		for(int i = 0;i < sigmaExpressionsArray.length;i++) {
			dimension = sigmaExpressionsArray[i].split("\\.")[0];
			currentLevel = sigmaExpressionsArray[i].split("\\.")[1].split("=")[0].replace("\n", "");
			for(int j = 0;j < cubeManager.getDimensions().size();j++) {
				if(cubeManager.getDimensions().get(j).getName().equals(dimension)) {
					for(int k = 0;k < cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().size();k++) {
						if(cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k).getName().equals(currentLevel)) {
							positionInHierarchy = cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k).getPositionInHierarchy();
							if(positionInHierarchy < cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().size() - 1) {
								tableName = cubeManager.getDimensions().get(j).getTableName();
								parentLevelByDescription = cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k+1).getLevelDescriptionAttribute();
								parentLevel = cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k+1).getName();
								currentLevelByDescription = cubeManager.getDimensions().get(j).getHierarchy().get(0).getLevels().get(k).getLevelDescriptionAttribute();
								parentValue = findParentValue(tableName,parentLevel,parentLevelByDescription,currentLevel,currentLevelByDescription,sigmaExpressionsArray[i]);
								String sigmaExpression = dimension + "." + parentLevel + "="  + parentValue;
								parentSigmaExpressions.add(sigmaExpression);
							}else {
								parentSigmaExpressions.add(sigmaExpressionsArray[i]);
							}
						}
					}
				}
			}
		}
		
		// build the siblings gamma expressions
		for(int i = 0;i < sigmaExpressionsArray.length;i++) {
			for(int j = 0;j < gammaExpressionsArray.length;j++) {
				siblingsGammaExpressionsStringForm.add("Gamma:" + gammaExpressionsArray[j].replace("\n", "") + "," + sigmaExpressionsArray[i].split("=")[0].replace("\n", "") + "\n");
			}
		}
		
		// build the siblings sigma expressions
		for(int i = 0;i < parentSigmaExpressions.size();i++) {
			if(i == index) {
				index++;
				expression = "Sigma:" + parentSigmaExpressions.get(i);
				if(sigmaExpressionsArray.length != 1) {
					expression += ",";
				}
				while(index < sigmaExpressionsArray.length) {
					expression += sigmaExpressionsArray[index];
					if(index != sigmaExpressionsArray.length - 1) {
						expression += ",";
					}
					index++;
				}
				expression = expression.replace("\n","");
				expression += "\n";
				siblingsSigmaExpressionsStringForm.add(expression);
			}else {
				expression = "Sigma:";
				while(index < sigmaExpressionsArray.length) {
					if(index == i) {
						expression += parentSigmaExpressions.get(index);
					}else {
						expression += sigmaExpressionsArray[index];
					}
					if(index != sigmaExpressionsArray.length - 1) {
						expression += ",";
					}
					index++;
				}
				expression = expression.replace("\n", "");
				expression += "\n";
				siblingsSigmaExpressionsStringForm.add(expression);
			}
			index = 0;
		}
		
		// create the siblings cube queries and store them to the analyzeCubeQueries ArrayList
		for(String sigma: siblingsSigmaExpressionsStringForm) {
			for(int i = 0;i < 2;i++) {
				String gamma = siblingsGammaExpressionsStringForm.get(0);
				siblingQueryParams.clear();
				siblingCubeQString = cubeName + "Name:AnalyzeBaseQuery-Sibling " + counter + "\n" + aggregateFunction + measure + gamma + sigma;
				siblingQueryParams.put("CubeName", cubeName);
				siblingQueryParams.put("Name", "AnalyzeBaseQuery-Drill Down " + counter);
				siblingQueryParams.put("AggrFunc", aggregateFunction);
				siblingQueryParams.put("Measure", measure);
				siblingQueryParams.put("Gamma", gamma);
				siblingQueryParams.put("Sigma", sigma);
				
				// create the query and store it
				try {
					siblingAnalyzeBaseQuery = cubeManager.createCubeQueryFromString(siblingCubeQString, siblingQueryParams);
					analyzeCubeQueries.add(siblingAnalyzeBaseQuery);
				} catch (RemoteException e) {
					e.printStackTrace();
				}
				counter++;
				siblingsGammaExpressionsStringForm.remove(0);
			}
		}
		
	}
	
	/**
	 * Auxiliary method that finds the parent value of a hierarchy by querying the cube
	 * @param tableName The table of the hierarchies to be queried
	 * @param parentLevel The parent hierarchy
	 * @param parentLevelByDescription The parent hierarchy description
	 * @param currentLevel The current hierarchy
	 * @param currentLevelByDescription The current hierarchy description
	 * @param sigmaExpression The sigma expression of the current hierarchy
	 * @return A String value that contains the parent value
	 */
	private String findParentValue(String tableName,String parentLevel,String parentLevelByDescription,String currentLevel,String currentLevelByDescription,String sigmaExpression) {
		Result queryResult = new Result();
		String result;
		String retString;
		
		// get tableName and sigmaExpression in the necessary form to query the cube
		tableName = "pkdd99_star." + tableName;
		sigmaExpression = currentLevelByDescription + "=" + sigmaExpression.split("=")[1].replace("\n", "");
		
		// if the parent level is top hierarchy return ALL String value
		if(parentLevel.contains("All")) {
			retString = "'" + "ALL" + "'";
			return retString;
		}
		
		// Query the cube and get its result which is the parent value
		String SQLQuery = "SELECT DISTINCT " + parentLevelByDescription + " FROM " + tableName + " WHERE " + sigmaExpression + ";";
		System.out.println(SQLQuery);
		queryResult = cubeManager.getCubeBase().executeQueryToProduceResult(SQLQuery, queryResult);
		String[][] resultArray = queryResult.getResultArray();
		result = resultArray[2][0];
		retString =  "'" + result + "'";
		return retString;
	}
	
	/** At this point the method translates the incoming expressions and fills the analyzeCubeQueries ArrayList.
	 * 
	 * @return (for now) it returns the status of the method.
	 */
	public int execute() {
		// TODO Auto-generated method stub
		//this must return a Intentional Result object, not null, not void, not int
		int status = -1;
		translateInputAnalyzeExpressionToCubeQueries();
		return status;
	}
}
